name: SonarQube Workflow

on:
  workflow_call:
    secrets:
      SONAR_TOKEN:
        required: true
      SONAR_PROJECT_KEY:  
        required: true

jobs:
  # Performs a static analysis of the source code.
  # Returns a list of 'security hotspots' that indicate potential software weaknesses
  sonar:
    runs-on: ubuntu-latest
    steps:
      # Check out source code from the repository
      - name: Checkout code
        uses: actions/checkout@v4
        
      # Preforms SonarQube scan and stores results on external SonarQube dashboard.
      # @SONAR_TOKEN: token used for SonarQube authentication, specific to the SonarQube environment
      # @SONAR_PROJECT_VERSION: version of the SonarQube project.
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_VERSION: '1.0'  

      # Retrieve security issues from external SonarQube dashboard via a cURL command. 
      # The issues are saved and stored in an issues.json file to use in the next step.
      # @SONAR_TOKEN: token used for SonarQube authentication, specific to the SonarQube environment
      # @SONAR_PROJECT_KEY: This key is specific to the SonarQube project. It specifies which
      # project issues to retrieve
      - name: Get SonarQube Issues
        id: get_issues
        run: |
          curl -s -u ${{ secrets.SONAR_TOKEN }} \
            "https://sonarcloud.io/api/issues/search?projectKeys=${{ secrets.SONAR_PROJECT_KEY }}" \
            | jq -c '[.issues[]]' > issues.json  
    
          echo "::set-output name=issues::$(cat issues.json)" 
    
      # Use the issues.json to generate GitHub issues via cURL command. These issues can be linked to a planning tool.
      # @GITHUB_TOKEN: A token specific to a GitHub repository. This specifies in which project
      # the issues are uploaded.
      - name: Create GitHub Issues
        if: steps.get_issues.outputs.issues != ''
        run: |
          jq -c '.[]' issues.json | while read -r issue; do
              TITLE=$(echo "$issue" | jq -r '.message')  # Extract issue title
              UNIQUE_KEY=$(echo "$issue" | jq -r '.key')  # Extract unique key for the issue
              BODY="Severity: $(echo "$issue" | jq -r '.severity')\nFile: $(echo "$issue" | jq -r '.component')\nDescription: $(echo "$issue" | jq -r '.description')\n\nUnique Key: $UNIQUE_KEY"

              echo "Checking if issue already exists with title: $TITLE and key: $UNIQUE_KEY"

              # Check if the issue already exists in GitHub
              existing_issue=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/lucvdacker/DPaaS/issues?state=open&filter=all&per_page=100" \
                | jq -r --arg TITLE "$TITLE" --arg UNIQUE_KEY "$UNIQUE_KEY" '.[] | select(.title == $TITLE and (.body | contains($UNIQUE_KEY))) | .number')

              if [ -n "$existing_issue" ]; then
                  echo "Issue already exists: #$existing_issue. Skipping creation."
              else
                  echo "Creating new issue with title: $TITLE"
                  response=$(curl -X POST \
                    -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    https://api.github.com/repos/lucvdacker/DPaaS/issues \
                    -d "{\"title\": \"$TITLE\", \"body\": \"$BODY\"}")

                  echo "Response: $response"  # Output response from GitHub API
              fi
          done
      
      # Verify whether the scan meets the criteria in the Quality gate set up in SonarQube.
      # When the Quality Gate is not met, an error is given and the build is blocked.
      - name: Check Quality Gate
        run: |
          STATUS=$(curl -s -u ${{ secrets.SONAR_TOKEN }} \
            "https://sonarcloud.io/api/qualitygates/project_status?projectKey=${{ secrets.SONAR_PROJECT_KEY }}" \
            | jq -r '.projectStatus.status')
          if [ "$STATUS" != "OK" ]; then
            echo "::error ::Quality gate failed: $STATUS"
            exit 1  # Exit with error
          fi

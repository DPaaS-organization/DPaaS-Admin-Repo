name: SonarQube Workflow

on:
  workflow_call:
    secrets:
      SONAR_TOKEN:
        required: true
      SONAR_PROJECT_KEY:  
        required: true

jobs:
  # Performs a static analysis of the source code.
  # Returns a list of 'security hotspots' that indicate potential software weaknesses
  sonar:
    runs-on: ubuntu-latest
    steps:
      # Check out source code from the repository
      - name: Checkout code
        uses: actions/checkout@v4
        
      # Preforms SonarQube scan and stores results on external SonarQube dashboard.
      # @SONAR_TOKEN: token used for SonarQube authentication, specific to the SonarQube environment
      # @SONAR_PROJECT_VERSION: version of the SonarQube project.
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_VERSION: '1.0'  

      # Retrieve security issues from external SonarQube dashboard via a cURL command. 
      # The issues are saved and stored in an issues.json file to use in the next step.
      # @SONAR_TOKEN: token used for SonarQube authentication, specific to the SonarQube environment
      # @SONAR_PROJECT_KEY: This key is specific to the SonarQube project. It specifies which
      # project issues to retrieve
      - name: Get SonarQube Issues
        id: get_issues
        run: |
          curl -s -u ${{ secrets.SONAR_TOKEN }} \
            "https://sonarcloud.io/api/issues/search?projectKeys=${{ secrets.SONAR_PROJECT_KEY }}" \
            | jq -c '[.issues[]]' > issues.json  
    
          echo "::set-output name=issues::$(cat issues.json)" 
    
      # Use the issues.json to generate GitHub issues via cURL command. These issues can be linked to a planning tool.
      # @GITHUB_TOKEN: A token specific to a GitHub repository. This specifies in which project
      # the issues are uploaded.
      - name: Create GitHub Issues
        if: steps.get_issues.outputs.issues != ''
        run: |
          jq -c '.[]' issues.json | while read -r issue; do
              TITLE=$(echo "$issue" | jq -r '.message')  # Extract issue title
              UNIQUE_KEY=$(echo "$issue" | jq -r '.key')  # Extract unique key for the issue
              BODY="Severity: $(echo "$issue" | jq -r '.severity')\nFile: $(echo "$issue" | jq -r '.component')\nDescription: $(echo "$issue" | jq -r '.description')\n\nUnique Key: $UNIQUE_KEY"

              echo "Checking if issue already exists with title: $TITLE and key: $UNIQUE_KEY"

              # Check if the issue already exists in GitHub
              existing_issue=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/lucvdacker/DPaaS/issues?state=open&filter=all&per_page=100" \
                | jq -r --arg TITLE "$TITLE" --arg UNIQUE_KEY "$UNIQUE_KEY" '.[] | select(.title == $TITLE and (.body | contains($UNIQUE_KEY))) | .number')

              if [ -n "$existing_issue" ]; then
                  echo "Issue already exists: #$existing_issue. Skipping creation."
              else
                  echo "Creating new issue with title: $TITLE"
                  response=$(curl -X POST \
                    -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    https://api.github.com/repos/lucvdacker/DPaaS/issues \
                    -d "{\"title\": \"$TITLE\", \"body\": \"$BODY\"}")

                  echo "Response: $response"  # Output response from GitHub API
              fi
          done
      
      # Verify whether the scan meets the criteria in the Quality gate set up in SonarQube.
      # When the Quality Gate is not met, an error is given and the build is blocked.
      - name: Check Quality Gate
        run: |
          STATUS=$(curl -s -u ${{ secrets.SONAR_TOKEN }} \
            "https://sonarcloud.io/api/qualitygates/project_status?projectKey=${{ secrets.SONAR_PROJECT_KEY }}" \
            | jq -r '.projectStatus.status')
          if [ "$STATUS" != "OK" ]; then
            echo "::error ::Quality gate failed: $STATUS"
            exit 1  # Exit with error
          fi

  # Performs an OWASP ZAP scan. This is a dynamic test of a fully running application.
  # Firstly the application must be started in a Docker environment.
  zap_scan:
    runs-on: ubuntu-latest
    name: DAST Webapp scan
    steps:
    # Check out source code from the repository.
    - name: Checkout
      uses: actions/checkout@v4
      with:
        ref: main

    # Pull the latest version of the Docker image and start it in detached mode. 
    # Detached mode means another task can be executed simultaniously
    - name: Run Juice Shop image
      run: | 
        docker pull bkimminich/juice-shop  # Pull the Juice Shop image
        docker run -p 3000:3000 --detach bkimminich/juice-shop  # Run the image in detached mode

    # OWASP ZAP scan is executed on the Docker environment.
    # @GITHUB_TOKEN: A token specific to a GitHub repository. This specifies in which project
    # the issues are uploaded.
    - name: ZAP SCAN
      uses: zaproxy/action-full-scan@v0.12.0
      with:
        token: ${{ secrets.GITHUB_TOKEN }}  # Token for GitHub authentication
        docker_name: 'ghcr.io/zaproxy/zaproxy:stable'  # Docker image for ZAP
        target: 'http://localhost:3000'  # Target URL for the scan
        rules_file_name: '.zap/rules.tsv'  # Custom rules for the scan
        cmd_options: '-a'  # Additional command options

    # Generate a report of the OWASP ZAP scan in JSON format.
    - name: Generate ZAP Report
      run: |
        docker run --rm -v ${{ github.workspace }}:/zap/wrk/:rw ghcr.io/zaproxy/zaproxy:stable zap.sh -cmd -quickurl http://localhost:3000 -quickout /zap/wrk/zap_report.json

    # Create GitHub issues for findings from the ZAP report
    - name: Create GitHub Issues for Findings
      run: |
        findings=$(jq -c '.site[].alerts[]' zap_report.json)  # Parse findings from the report

        if [ -z "$findings" ]; then
            echo "No findings to process."  # Exit if no findings
            exit 0
        fi
  
        echo "$findings" | while read -r finding; do
          TITLE=$(echo "$finding" | jq -r '.alert')  # Extract alert title
          DESCRIPTION=$(echo "$finding" | jq -r '.description')  # Extract alert description
          SEVERITY=$(echo "$finding" | jq -r '.severity')  # Extract alert severity

          echo "Title: $TITLE"
          echo "Description: $DESCRIPTION"
          echo "Severity: $SEVERITY"

          # Create a new GitHub issue for each finding
          response=$(curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/issues \
            -d "{\"title\": \"$TITLE\", \"body\": \"Severity: $SEVERITY\n\n$DESCRIPTION\"}")

          echo "Created issue: $response"  # Output response from GitHub API
        done

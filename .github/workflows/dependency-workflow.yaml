name: Generate CycloneDX SBOM for Multiple Formats

on:
  workflow_call:

jobs:
  generate-sbom:
    runs-on: ubuntu-latest

    steps:
      # Checkout code from the repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Set up Node.js environment
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '16'  # Specify the Node.js version

      # Install npm dependencies if package.json has changed
      - name: Install npm dependencies
        if: hashFiles('package.json')
        run: npm install --legacy-peer-deps

      # Install a specific missing npm dependency
      - name: Install missing dependencies
        if: hashFiles('package.json')
        run: npm install eslint-plugin-n@15 --save-dev

      # Force install a specific TypeScript version
      - name: Force install TypeScript version
        if: hashFiles('package.json')
        run: npm install typescript@4.6.4 --save-dev --force

      # Generate CycloneDX SBOM for npm
      - name: Generate CycloneDX SBOM for npm
        if: hashFiles('package.json')
        run: npx @cyclonedx/cyclonedx-npm --output-file sbom-npm.json

      # Set up Python environment if requirements.txt or setup.py exists
      - name: Set up Python
        if: hashFiles('requirements.txt') || hashFiles('setup.py')
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'  # Specify the Python version

      # Install pip dependencies if requirements.txt or setup.py exists
      - name: Install pip dependencies
        if: hashFiles('requirements.txt') || hashFiles('setup.py')
        run: pip install -r requirements.txt

      # Generate CycloneDX SBOM for pip
      - name: Generate CycloneDX SBOM for pip
        if: hashFiles('requirements.txt') || hashFiles('setup.py')
        run: cyclonedx-py --output sbom-pip.json

      # Set up Java environment if pom.xml exists
      - name: Set up Java
        if: hashFiles('pom.xml')
        uses: actions/setup-java@v4
        with:
          java-version: '11'  # Specify the Java version
          distribution: 'adopt'

      # Install Maven dependencies if pom.xml exists
      - name: Install Maven dependencies
        if: hashFiles('pom.xml')
        run: mvn install

      # Generate CycloneDX SBOM for Maven
      - name: Generate CycloneDX SBOM for Maven
        if: hashFiles('pom.xml')
        run: mvn cyclonedx:makeAggregateBom

      # Set up Ruby environment if Gemfile exists
      - name: Set up Ruby
        if: hashFiles('Gemfile')
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '2.7'  # Specify the Ruby version

      # Install Bundler dependencies if Gemfile exists
      - name: Install Bundler dependencies
        if: hashFiles('Gemfile')
        run: bundle install

      # Generate CycloneDX SBOM for Bundler
      - name: Generate CycloneDX SBOM for Bundler
        if: hashFiles('Gemfile')
        run: cyclonedx-bundler --output sbom-bundler.json

      # Debugging: List generated SBOM files
      - name: List Generated SBOM Files
        run: ls -lh sbom-*.json target || echo "No SBOM files found"

      # Merge SBOMs into one unified SBOM
      - name: Merge SBOMs
        run: |
          # Initialize an array to hold existing SBOM files
          sbom_files=()

          # Check for the existence of each SBOM file and add to the array if it exists
          if [ -f sbom-npm.json ]; then
            sbom_files+=("sbom-npm.json")
          fi

          if [ -f sbom-pip.json ]; then
            sbom_files+=("sbom-pip.json")
          fi

          if [ -f target/cyclonedx-bom.xml ]; then
            sbom_files+=("target/cyclonedx-bom.xml")
          fi

          if [ -f sbom-bundler.json ]; then
            sbom_files+=("sbom-bundler.json")
          fi

          # Check if any SBOM files were found
          if [ ${#sbom_files[@]} -eq 0 ]; then
            echo "No SBOM files found to merge."
            exit 1
          fi

          # Use jq to merge the existing SBOMs into one unified SBOM
          jq -s 'reduce .[] as $item ({}; . * $item)' "${sbom_files[@]}" > sbom.json

      # Upload the Unified SBOM
      - name: Upload Unified SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.json

  push-sbom:
    runs-on: self-hosted
    needs: generate-sbom # Ensures this job runs only after generate-sbom is complete

    steps:
      # Download the SBOM artifact
      - name: Download SBOMs
        uses: actions/download-artifact@v4
        with:
          name: sbom

      # Wrap SBOM in required JSON structure
      - name: Wrap SBOM in required JSON structure
        run: |
          SBOM_CONTENT=$(base64 -w 0 sbom.json || echo "")  # Adjusted path
          if [ -z "$SBOM_CONTENT" ]; then
            echo "SBOM file is empty or missing."
            exit 1
          fi
          echo "{\"project\": \"44a6cbda-f849-4e1b-9943-52be44169eb1\", \"bom\": \"$SBOM_CONTENT\"}" > payload.json
      
      # Submit the SBOM to the API
      - name: Submit SBOM to API
        run: |
          RESPONSE=$(curl -s -X "PUT" "http://localhost:8081/api/v1/bom" \
          -d @payload.json \
          -H "X-Api-Key: ${{ secrets.DEPENDENCY_TRACK_API_KEY }}" \
          -H "Content-Type: application/json")
          
          echo "API Response: $RESPONSE"
          if [[ "$RESPONSE" == *"error"* ]]; then
            echo "Failed to upload SBOM."
            exit 1
          fi
          
  verify-dependency-list:
    runs-on: ubuntu-latest
    needs: generate-sbom # Ensures this job runs only after generate-sbom is complete
    
    steps:
    # Download the SBOM artifact
    - name: Download SBOMs
      uses: actions/download-artifact@v4
      with:
        name: sbom

    # Download managed dependencies from a remote JSON file
    - name: Download Managed Dependencies
      env:
        TOKEN: ${{ secrets.ADMIN_ACCESS_TOKEN }} # Or use a PAT if required
      run: |
        curl -s -X GET \
        https://raw.githubusercontent.com/DPaaS-organization/DPaaS-Admin-Repo/main/managed-dependencies.json \
        -H "Authorization: token $TOKEN" \
        -H "Content-Type: application/json"  -vv -o managed-dependencies.txt

    - name: Debug `managed-dependencies.txt`
      run: |
        cat managed-dependencies.txt

    # # Validate the structure of the managed dependencies JSON file
    # - name: Validate JSON
    #   run: |
    #     jq empty managed-dependencies.json || (echo "Invalid JSON" && exit 1)

    # - name: Extract Managed Dependencies
    #   run: |
    #     jq -r '.managedDependencies | keys[]' managed-dependencies.json > managed-dependencies.txt

    # # Extract managed dependencies from the downloaded JSON
    # - name: Extract Managed Dependencies
    #   run: |
    #     jq -r 'keys[]' managed-dependencies.json > managed-dependencies.txt

    # # Verify that all SBOM dependencies are in the managed dependencies list
    # - name: Verify Dependencies
    #   run: |
    #     # Compare the two lists
    #     if ! comm -12 <(sort sbom-dependencies.txt) <(sort managed-dependencies.txt) > /dev/null; then
    #       echo "Some dependencies are not in the managed dependencies list."
    #       exit 1
    #     fi

    - name: Parse SBOM to Dependencies List
      run: |
        # Extract dependency names from the SBOM
        jq -r '.components[].name' sbom.json > sbom-dependencies.txt
        echo "Parsed SBOM Dependencies:"
        cat sbom-dependencies.txt

    # Verify Dependencies
    - name: Verify Dependencies
      run: |
        # Compare the two lists using comm
        if ! comm -12 <(sort sbom-dependencies.txt) <(sort managed-dependencies.txt) > /dev/null; then
          echo "Some dependencies in the SBOM are NOT in the managed dependencies list."
          exit 1
        else
          echo "All SBOM dependencies are present in the managed dependencies list."
        fi
        
  fetch-scan-from-dependency-track:
    runs-on: self-hosted
    needs: push-sbom # Ensures this job runs only after push-sbom is complete

    steps:
      - name: Check Scan Status
        id: check-status
        run: |
          PROJECT_UUID="44a6cbda-f849-4e1b-9943-52be44169eb1"
          SCAN_COMPLETE=false
          while [ "$SCAN_COMPLETE" = false ]; do
          RESPONSE=$(curl -s -X GET "http://localhost:8081/api/v1/project/${PROJECT_UUID}" \
              -H "X-Api-Key: ${{ secrets.DEPENDENCY_TRACK_API_KEY }}" \
              -H "Content-Type: application/json" -vv)
      
            echo "API Response: $RESPONSE"  # Debugging line

            SCAN_STATUS=$(echo "$RESPONSE" | jq -r '.lastAnalysisStatus')
      
            if [ "$SCAN_STATUS" = "ANALYZED" ]; then
              SCAN_COMPLETE=true
              echo "Scan completed successfully."
            elif [ "$SCAN_STATUS" = "IN_PROGRESS" ]; then
              echo "Scan still in progress. Waiting..."
              sleep 30
            else
              echo "Scan completed with status: $SCAN_STATUS"
              SCAN_COMPLETE=true
            fi
          done
      - name: Debug Scan Results
        run: |
          echo "Scan Results:"
          cat scan-results.json
      - name: Debug Parsed Findings
        run: |
          jq -c '.[]' scan-results.json

      - name: Fetch Scan Results
        id: fetch-results
        run: |
          curl -X GET "http://localhost:8081/api/v1/vulnerability/project/44a6cbda-f849-4e1b-9943-52be44169eb1" \
            -H "X-Api-Key: ${{ secrets.DEPENDENCY_TRACK_API_KEY }}" \
            -H "Content-Type: application/json" -o scan-results.json -vv

      - name: Create GitHub Issues for Vulnerabilities
        run: |
          # Parse the scan results and create issues
          findings=$(jq -c '.[]' scan-results.json)
      
          if [ -z "$findings" ]; then
            echo "No vulnerabilities to process."
            exit 0
          fi
      
          echo "$findings" | while read -r finding; do
            VULN_ID=$(echo "$finding" | jq -r '.vulnId // "UNKNOWN"')
            SOURCE=$(echo "$finding" | jq -r '.source // "UNKNOWN"')
            SEVERITY=$(echo "$finding" | jq -r '.severity // "UNASSIGNED"')
            DESCRIPTION=$(echo "$finding" | jq -r '.description // "No description available."')
            PACKAGE=$(echo "$finding" | jq -r '.package // empty')
            VULNERABLE_VERSIONS=$(echo "$finding" | jq -r '.vulnerableVersions // "N/A"')
            PATCHED_VERSIONS=$(echo "$finding" | jq -r '.patchedVersions // "N/A"')
            REFERENCES=$(echo "$finding" | jq -r '
              if (.references | type == "array") then
                .references | join("\n* ")
              elif (.references | type == "string") then
                .references
              else
                "No references available"
              end
            ')
      
            TITLE="Vulnerability: $PACKAGE ($SEVERITY)"
            BODY="**Source:** $SOURCE  
                  **Severity:** $SEVERITY  
                  **Description:** $DESCRIPTION  
                  
                  **Vulnerable Versions:** $VULNERABLE_VERSIONS  
                  **Patched Versions:** $PATCHED_VERSIONS  
                  
                  **References:** $REFERENCES"
      
            echo "Checking if an open issue already exists for package: $PACKAGE"
      
            # # Check if an open issue already exists for the vulnerable package
            # existing_issues=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            #   -H "Accept: application/vnd.github.v3+json" \
            #   "https://api.github.com/repos/${{ github.repository }}/issues?state=open" | jq -r --arg package "$PACKAGE" '.[] | select(.title | contains($package)) | .title')
      
            # if [ -n "$existing_issues" ]; then
            #   echo "An open issue already exists for package: $PACKAGE. Skipping creation."
            #   continue
            # fi
      
            echo "Creating issue: $TITLE"
      
            # Create a new GitHub issue for each finding
            response=$(curl -s -o response.json -w "%{http_code}" -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues \
              -d "$(jq -n \
                --arg title "$TITLE" \
                --arg body "$BODY" \
                --argjson labels "[\"$SEVERITY\"]" \
                '{title: $title, body: $body, labels: $labels}')")
      
            http_status=$(cat response.json | tail -n 1)
            if [ "$http_status" -ne 201 ]; then
              echo "Failed to create issue: $(cat response.json)"
              exit 1
            else
              echo "Issue created successfully: $(cat response.json)"
            fi
          done

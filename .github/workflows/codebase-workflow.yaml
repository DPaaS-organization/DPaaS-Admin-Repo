name: ci-workflow

on:
  workflow_call:

jobs:
  sonar:
    runs-on: ubuntu-latest
    steps:
      # Step to checkout the code from the repository
      - name: Checkout code
        uses: actions/checkout@v4
        
      # Step to perform a SonarQube scan on the code
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}  # Token for SonarQube authentication
          SONAR_PROJECT_VERSION: '1.0'  # Version of the project being scanned

      # Step to retrieve issues found by SonarQube
      - name: Get SonarQube Issues
        id: get_issues
        run: |
          curl -s -u ${{ secrets.SONAR_TOKEN }} \
            "https://sonarcloud.io/api/issues/search?projectKeys=${{ secrets.SONAR_PROJECT_KEY }}" \
            | jq -c '[.issues[]]' > issues.json  # Save issues to a JSON file
          echo "::set-output name=issues::$(cat issues.json)"  # Set output for later steps

      # Step to create GitHub issues for each SonarQube issue found
      - name: Create GitHub Issues
        if: steps.get_issues.outputs.issues != ''
        run: |
          jq -c '.[]' issues.json | while read -r issue; do
              TITLE=$(echo "$issue" | jq -r '.message')  # Extract issue title
              UNIQUE_KEY=$(echo "$issue" | jq -r '.key')  # Extract unique key for the issue
              BODY="Severity: $(echo "$issue" | jq -r '.severity')\nFile: $(echo "$issue" | jq -r '.component')\nDescription: $(echo "$issue" | jq -r '.description')\n\nUnique Key: $UNIQUE_KEY"

              echo "Checking if issue already exists with title: $TITLE and key: $UNIQUE_KEY"

              # Check if the issue already exists in GitHub
              existing_issue=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/lucvdacker/DPaaS/issues?state=open&filter=all&per_page=100" \
                | jq -r --arg TITLE "$TITLE" --arg UNIQUE_KEY "$UNIQUE_KEY" '.[] | select(.title == $TITLE and (.body | contains($UNIQUE_KEY))) | .number')

              if [ -n "$existing_issue" ]; then
                  echo "Issue already exists: #$existing_issue. Skipping creation."
              else
                  echo "Creating new issue with title: $TITLE"
                  response=$(curl -X POST \
                    -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    https://api.github.com/repos/lucvdacker/DPaaS/issues \
                    -d "{\"title\": \"$TITLE\", \"body\": \"$BODY\"}")

                  echo "Response: $response"  # Output response from GitHub API
              fi
          done
      
      # Step to check the quality gate status from SonarQube
      - name: Check Quality Gate
        run: |
          STATUS=$(curl -s -u ${{ secrets.SONAR_TOKEN }} \
            "https://sonarcloud.io/api/qualitygates/project_status?projectKey=${{ secrets.SONAR_PROJECT_KEY }}" \
            | jq -r '.projectStatus.status')
          if [ "$STATUS" != "OK" ]; then
            echo "::error ::Quality gate failed: $STATUS"  # Log error if quality gate fails
            exit 1  # Exit with error
          fi
  
  zap_scan:
    runs-on: ubuntu-latest
    name: DAST Webapp scan
    steps:
    # Step to checkout the code from the repository
    - name: Checkout
      uses: actions/checkout@v4
      with:
        ref: main

    # Step to pull and run the Juice Shop Docker image
    - name: Run Juice Shop image
      run: | 
        docker pull bkimminich/juice-shop  # Pull the Juice Shop image
        docker run -p 3000:3000 --detach bkimminich/juice-shop  # Run the image in detached mode

    # Step to perform a ZAP scan on the running application
    - name: ZAP SCAN
      uses: zaproxy/action-full-scan@v0.12.0
      with:
        token: ${{ secrets.GITHUB_TOKEN }}  # Token for GitHub authentication
        docker_name: 'ghcr.io/zaproxy/zaproxy:stable'  # Docker image for ZAP
        target: 'http://localhost:3000'  # Target URL for the scan
        rules_file_name: '.zap/rules.tsv'  # Custom rules for the scan
        cmd_options: '-a'  # Additional command options

    # Step to generate a ZAP report in JSON format
    - name: Generate ZAP Report
      run: |
        docker run --rm -v ${{ github.workspace }}:/zap/wrk/:rw ghcr.io/zaproxy/zaproxy:stable zap.sh -cmd -quickurl http://localhost:3000 -quickout /zap/wrk/zap_report.json

    # Step to create GitHub issues for findings from the ZAP report
    - name: Create GitHub Issues for Findings
      run: |
        findings=$(jq -c '.site[].alerts[]' zap_report.json)  # Parse findings from the report

        if [ -z "$findings" ]; then
            echo "No findings to process."  # Exit if no findings
            exit 0
        fi
  
        echo "$findings" | while read -r finding; do
          TITLE=$(echo "$finding" | jq -r '.alert')  # Extract alert title
          DESCRIPTION=$(echo "$finding" | jq -r '.description')  # Extract alert description
          SEVERITY=$(echo "$finding" | jq -r '.severity')  # Extract alert severity

          echo "Title: $TITLE"
          echo "Description: $DESCRIPTION"
          echo "Severity: $SEVERITY"

          # Create a new GitHub issue for each finding
          response=$(curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/issues \
            -d "{\"title\": \"$TITLE\", \"body\": \"Severity: $SEVERITY\n\n$DESCRIPTION\"}")

          echo "Created issue: $response"  # Output response from GitHub API
        done
